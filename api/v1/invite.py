from typing import Any, List
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from sqlalchemy import and_, func
import uuid
from datetime import datetime, timedelta
import logging

from app.core.config import settings
from app.core.security import create_access_token, get_current_user
from app.db.base import get_db
from app.models.invite import Invite
from app.models.user import User
from app.schemas.invite import (
    InviteCreate, InviteResponse, InviteListResponse, InviteValidateResponse,
    InviteUseRequest, InviteUseResponse, InviteGenerateResponse, InviteStatsResponse,
    InviteGenerateRequest
)

router = APIRouter(prefix="/invite", tags=["invite"])
logger = logging.getLogger(__name__)

@router.post("/generate", response_model=InviteGenerateResponse)
async def generate_invite(
    *,
    db: Session = Depends(get_db),
    invite_request: InviteGenerateRequest = InviteGenerateRequest(),
    current_user: User = Depends(get_current_user)
) -> Any:
    """
    Generate a new invite code (authenticated users only).
    Each user can generate up to 10 invites.
    """
    logger.info(f"Generating invite for user {current_user.id}")
    
    # Check current user's invite count
    current_invites_count = db.query(Invite).filter(
        Invite.generated_by == current_user.id
    ).count()
    
    if current_invites_count >= settings.INVITE_MAX_GENERATION_LIMIT:
        logger.warning(f"User {current_user.id} exceeded invite generation limit")
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail=f"You have reached the maximum limit of {settings.INVITE_MAX_GENERATION_LIMIT} invites"
        )
    
    # Calculate expiration time if provided
    expires_at = None
    if invite_request.expires_in_hours:
        expires_at = datetime.utcnow() + timedelta(hours=invite_request.expires_in_hours)
    
    # Create new invite
    try:
        db_invite = Invite(
            id=str(uuid.uuid4()),
            generated_by=current_user.id,
            max_uses=invite_request.max_uses,
            expires_at=expires_at,
            created_at=datetime.utcnow()
        )
        
        # Ensure unique invite code
        max_retries = 10
        retries = 0
        while retries < max_retries:
            try:
                db.add(db_invite)
                db.commit()
                db.refresh(db_invite)
                break
            except Exception as e:
                # If it's a uniqueness constraint error, generate a new code
                if "unique" in str(e).lower():
                    retries += 1
                    db.rollback()
                    db_invite.invite_code = Invite.generate_invite_code()
                    logger.warning(f"Duplicate invite code generated, retrying ({retries}/{max_retries})")
                    continue
                else:
                    raise e
        
        if retries >= max_retries:
            logger.error(f"Failed to generate unique invite code after {max_retries} attempts")
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail="Failed to generate unique invite code"
            )
        
        # Generate invite link (you can customize this URL format)
        invite_link = f"{settings.FRONTEND_URL if hasattr(settings, 'FRONTEND_URL') else 'http://localhost:3000'}/invite/{db_invite.invite_code}"
        
        logger.info(f"Successfully generated invite {db_invite.invite_code} for user {current_user.id}")
        
        return InviteGenerateResponse(
            invite_code=db_invite.invite_code,
            invite_link=invite_link,
            max_uses=db_invite.max_uses,
            expires_at=db_invite.expires_at,
            created_at=db_invite.created_at
        )
        
    except Exception as e:
        logger.error(f"Error generating invite for user {current_user.id}: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to generate invite"
        )

@router.get("/my-invites", response_model=List[InviteListResponse])
async def get_my_invites(
    *,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
) -> Any:
    """
    Get all invites generated by the current user.
    """
    logger.info(f"Fetching invites for user {current_user.id}")
    
    try:
        invites = db.query(Invite).filter(
            Invite.generated_by == current_user.id
        ).order_by(Invite.created_at.desc()).all()
        
        # Convert to response format with remaining uses
        response_invites = []
        for invite in invites:
            response_invites.append(InviteListResponse(
                id=invite.id,
                invite_code=invite.invite_code,
                max_uses=invite.max_uses,
                current_uses=invite.current_uses,
                is_active=invite.is_active,
                created_at=invite.created_at,
                expires_at=invite.expires_at,
                used_at=invite.used_at,
                remaining_uses=invite.remaining_uses()
            ))
        
        logger.info(f"Retrieved {len(response_invites)} invites for user {current_user.id}")
        return response_invites
        
    except Exception as e:
        logger.error(f"Error fetching invites for user {current_user.id}: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to fetch invites"
        )

@router.get("/stats", response_model=InviteStatsResponse)
async def get_invite_stats(
    *,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
) -> Any:
    """
    Get invite statistics for the current user.
    """
    logger.info(f"Fetching invite stats for user {current_user.id}")
    
    try:
        # Get all invites for the user
        total_invites = db.query(Invite).filter(
            Invite.generated_by == current_user.id
        ).count()
        
        # Get active invites
        active_invites = db.query(Invite).filter(
            and_(
                Invite.generated_by == current_user.id,
                Invite.is_active == True
            )
        ).count()
        
        # Get used invites (current_uses > 0)
        used_invites = db.query(Invite).filter(
            and_(
                Invite.generated_by == current_user.id,
                Invite.current_uses > 0
            )
        ).count()
        
        # Calculate remaining limit
        remaining_limit = max(0, settings.INVITE_MAX_GENERATION_LIMIT - total_invites)
        
        return InviteStatsResponse(
            total_invites_generated=total_invites,
            active_invites=active_invites,
            used_invites=used_invites,
            remaining_invite_limit=remaining_limit,
            max_invite_limit=settings.INVITE_MAX_GENERATION_LIMIT
        )
        
    except Exception as e:
        logger.error(f"Error fetching invite stats for user {current_user.id}: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to fetch invite statistics"
        )

@router.get("/validate/{invite_code}", response_model=InviteValidateResponse)
async def validate_invite(
    *,
    db: Session = Depends(get_db),
    invite_code: str
) -> Any:
    """
    Validate an invite code (unauthenticated endpoint).
    """
    logger.info(f"Validating invite code: {invite_code}")
    
    try:
        # Find the invite
        invite = db.query(Invite).filter(
            Invite.invite_code == invite_code
        ).first()
        
        if not invite:
            logger.warning(f"Invite code not found: {invite_code}")
            return InviteValidateResponse(
                valid=False,
                message="Invalid invite code"
            )
        
        # Check if invite is valid
        if not invite.is_valid():
            reason = "Invite code has expired" if invite.expires_at and datetime.utcnow() > invite.expires_at else "Invite code is no longer active"
            if invite.current_uses >= invite.max_uses:
                reason = "Invite code has been fully used"
            
            logger.warning(f"Invalid invite code {invite_code}: {reason}")
            return InviteValidateResponse(
                valid=False,
                message=reason,
                invite_code=invite_code
            )
        
        # Valid invite
        logger.info(f"Valid invite code: {invite_code}")
        return InviteValidateResponse(
            valid=True,
            message="Valid invite code",
            invite_code=invite_code,
            remaining_uses=invite.remaining_uses(),
            expires_at=invite.expires_at
        )
        
    except Exception as e:
        logger.error(f"Error validating invite code {invite_code}: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to validate invite code"
        )

@router.post("/use/{invite_code}", response_model=InviteUseResponse)
async def use_invite(
    *,
    db: Session = Depends(get_db),
    invite_code: str,
    request: InviteUseRequest = InviteUseRequest()
) -> Any:
    """
    Use an invite code to gain access (unauthenticated endpoint).
    Creates a guest user session or uses existing phone number.
    """
    logger.info(f"Using invite code: {invite_code}")
    
    try:
        # Find and validate the invite
        invite = db.query(Invite).filter(
            Invite.invite_code == invite_code
        ).first()
        
        if not invite:
            logger.warning(f"Invite code not found: {invite_code}")
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Invalid invite code"
            )
        
        if not invite.can_be_used():
            reason = "Invite code has expired" if invite.expires_at and datetime.utcnow() > invite.expires_at else "Invite code is no longer active"
            if invite.current_uses >= invite.max_uses:
                reason = "Invite code has been fully used"
            
            logger.warning(f"Cannot use invite code {invite_code}: {reason}")
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=reason
            )
        
        # Check if user exists with provided phone number
        guest_user = None
        if request.phone:
            guest_user = db.query(User).filter(User.phone == request.phone).first()
        
        # Create guest user if doesn't exist
        if not guest_user:
            # Generate a unique guest user ID
            guest_user_id = str(uuid.uuid4())
            phone_number = request.phone or f"guest_{guest_user_id[:8]}"
            
            # Ensure phone number is unique
            counter = 1
            original_phone = phone_number
            while db.query(User).filter(User.phone == phone_number).first():
                phone_number = f"{original_phone}_{counter}"
                counter += 1
            
            guest_user = User(
                id=guest_user_id,
                phone=phone_number,
                created_at=datetime.utcnow(),
                is_active=True,
                auth_method="invite"  # Mark as invite-based user
            )
            db.add(guest_user)
        
        # Use the invite
        if invite.use_invite(guest_user.id):
            db.add(invite)
            db.commit()
            db.refresh(guest_user)
            
            # Generate access token for guest user
            access_token = create_access_token(guest_user.id)
            
            logger.info(f"Successfully used invite {invite_code} for user {guest_user.id}")
            
            return InviteUseResponse(
                success=True,
                message="Invite code used successfully",
                access_token=access_token,
                token_type="bearer",
                user_id=guest_user.id,
                invite_code=invite_code,
                is_guest_user=True
            )
        else:
            logger.error(f"Failed to use invite {invite_code}")
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Failed to use invite code"
            )
            
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error using invite code {invite_code}: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to use invite code"
        ) 